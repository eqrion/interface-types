# Interface instructions

This proposal defines new instructions that operate over interface value types. These instructions have the same form as core instructions; they push and pop values on an execution stack and support single pass validation.

The new interface instructions are summarized below.

```
#interface-instr ::=
  | bool.lift_iMM
  | bool.lower_iMM

  | sNN.lift_iMM
  | sNN.lower_iMM

  | uNN.lift_iMM
  | uNN.lower_iMM

  | string.lift_memory ..
  | string.lower_memory ..

  | variant.lift ..
  | variant.lower_tag ..
  | variant.lower ..

  | record.lift ..
  | record.lower ..

  | array.lift_memory ..
  | array.lower_memory ..

  | callback.lift ..
  | callback.lower ..

  | defer ..

where:
  NN is one of [8, 16, 32, 64]
  MM is one of [32, 64]
```

In addition the following instructions are included from the core instructions:

```
#interface-instr ::=
  | ..
  | <numeric instructions>
  | <parametric instructions>
  | <variable instructions>
  | <memory instructions>
  | <table instructions>
  | block ..
  | br ..
  | br_if ..
  | br_table ..
  | return
  | call ..
  | unreachable
  | nop
```

Refer to the definition of instruction classes [here](https://webassembly.github.io/spec/core/syntax/instructions.html).

## Laziness

Interface values generated by interface instructions are lazy. The execution of an instruction generating an interface value happens immediately before the instruction that consumes the value.

The variable instructions are included in interface instructions, allowing locals to be used in an interface function. Locals remain limited to the core value types, as they would conflict with optimizing laziness of interface values.

In addition, no interface instruction is allowed to consume and then return an interface value (such as a `tee` or `select` operation). This would require caching of the first lazy execution of the source instruction, and complicate analysis of interface functions.

The drop instruction triggers any side effects of the lifting operation, such as out-of-bounds, but does not use the resulting interface value in any way.

## Calling

The `call` instruction may call an interface function. Calling an interface function is effectively the same as inlining the function in the caller's scope.

This means that interface values are not consumed when passed as params to a call, but later when used in a lowering instruction inside the . This also means that interface functions are statically disallowed from forming a recursive call graph.

## `bool.lift_iMM`

This instruction has type `[iMM] -> [bool]`.

The output is `true` iff the input `iMM` has any bit set in the integer.

## `bool.lower_iMM`

This instruction has type `[bool] -> iMM`.

The output is `0b1` zero extended to the desired bitwidth iff the input is true.

## `sNN.lift_iMM`

This instruction has type `iMM` -> `sNN`.

The output is the value of `iMM` as a two's complement signed integer.

If this cannot be represented in the desired type, then this instruction traps.

## `sNN.lower_iMM`

This instruction has type `[sNN] -> [iMM]`

The output is the value of `sNN` as a two's complement signed integer.

If this cannot be represented in the desired type, then this instruction traps.

## `uNN.lift_iMM`

This instruction has type `iMM` -> `uNN`.

The output is the value of `iMM` as an unsigned integer.

If this cannot be represented in the desired type, then this instruction traps.

## `uNN.lower_iMM`

This instruction has type `[uNN] -> [iMM]`

The output is the value of `uNN` as an unsigned integer.

If this cannot be represented in the desired type, then this instruction traps.

## `string.lift_memory #memidx #encoding`

The type of this instruction is:
```
[$base: i32, $len: i32] -> [string]
```

The output is a sequence of unicode code points taken by interpreting `store.memory[$memidx].bytes[$base .. $base + $len]` with `#encoding`.

This instructions traps if the range `$base .. $base + $len` is out-of-bounds, or the byte sequence is not valid under `#encoding`.

The syntax for supported encodings is:
```
#encoding ::=
  | utf8
  | utf16
```

## `string.lower_memory #memidx #encoding $alloc: #funcidx`

The type of this instruction is:
```
[string] -> [i32, i32]

Where:
  * $alloc has a valid functype of [i32] -> [i32]
```

The instruction will execute the following steps:
```
  1. Let $length be the bytes required to encode the string with #encoding
  2. Call $alloc with $length and receive an offset into #memidx
  3. Encode the string into the offset at memory
```

## `record.lift #typeidx`

The type of this instruction is:
```
[$a, $b, ..] -> [$type]

Where:
  * $type is a type of the form (record $fields) taken from #typeidx
  * $a, $b, .. are the #interface-valtype's for each field in $fields
```

The output is a record interface value with fields given by the inputs.

## `record.lower #typeidx`

The type of this instruction is:
```
[$type] -> [$fields]

Where:
  * $type is a valid type of the form (record $fields) taken from #typeidx
```

The outputs are the fields of the input `record`.

## `variant.lift #typeidx $tag: #u32`

The type of this instruction is:
```
[$payload] -> [$type]

Where:
  * $type is a type of the form (variant $options) taken from #typeidx
  * $tag is an index of an (option #interface-valtype) from `$options`
  * $payload = #interface-valtype
```

The output is a variant interface value with `tag` given by `$tag` and `payload` given by input.

## `variant.lower_tag #typeidx`

The type of this instruction is:
```
[$type] -> [i32]

Where:
 * $type is a valid type of the form (variant ..) taken from #typeidx
```

The output is the value of the `tag` of the input `variant`.

## `variant.lower #typeidx $result: #interface-valtype*`

This is a structured instruction with the following syntax:

```
variant.lower #typeidx $result: #interface-valtype*
  (case $tag #interface-instr*)+
end
```

The type of this instruction is:
```
[$type] -> [$result]

Where:
  * $type is a valid type of the form (variant $options) taken from #typeidx
  * Each $tag uniquely matches an index of an option of $options
  * Every option of $options is referenced by a case
  * Each #interface-instr* is valid with the type [] -> [$result]
```

The output is the value of executed the matching `case` for the `tag` of the input `variant`.

## `array.lift_memory #typeidx $width: #u32`

This is a structured instruction with the following syntax:

```
array.lift_memory #typeidx $width: #u32
  interface-instr*
end
```

The type of this instruction is:
```
[$base: i32, $length: i32] -> [$type]

Where:
  * $type is a type of the form (array $inner) taken from #typeidx
  * #interface-instr* is valid with type [i32] -> [$inner]
```

This instruction will execute the following steps:
```
  1. Let $offsets = take([$base, $base + $width, $base + $width * 2, ..], $length)
  2. Map #interface-instr* upon $offsets to yield the elements of the array
```

## `array.lower_memory #typeidx #memidx $alloc: #funcidx $width: #u32`

This is a structured instruction with the following syntax:

```
array.lower_memory #typeidx #memidx $alloc: #funcidx $width: #u32
  interface-instr*
end
```

The type of this instruction is:
```
[$type] -> []

Where:
  * $type is a valid type of the form (array $inner) taken from #typeidx
  * $alloc has a valid functype of [i32] -> [i32]
  * #interface-instr* is valid with type [i32, $inner] -> []
```

This instruction will execute the following steps:
```
  1. Let $elems be the elements of the array
  2. Let $length be the length of the array
  3. Let $bytes be '$length * $width'
  4. Let $base = $alloc($bytes)
  5. Let $offsets = take([$base, $base + $width, $base + $width * 2, ..], $length)
  6. Let $params = zip($offsets, $elems)
  7. Map #interface-instr* upon $params
```

## `callback.lift #typeidx $environment: #interface-valtype* $exec: #interface-funcidx $dtor: #interface-funcidx`

The type of this instruction is:
```
[$environment] -> [$type]

Where:
  * $type is a valid type of the form (callback $params $results) taken from #typeidx
  * $exec has a valid interface-functype of [$environment $params] -> [$results]
  * $dtor has a valid interface-functype of [$environment] -> []
```

The output is a callback interface value with `exec` and `dtor` funcs. The `exec` and `dtor` funcs are closures that will call `$exec`/`$dtor` with the `$environment` provided to the lifting instruction.

## `callback.lower #typeidx $params-adapter: #interface-funcidx $results-adapter: #interface-funcidx`

The type of this instruction is:
```
[$type] -> [$e, $d]

Where:
  * $type is a valid type of the form (callback $params $results) taken from #typeidx
  * $params-adapter has a valid interface-functype of [$x] -> [$params]
  * $results-adapter has a valid interface-functype of [$results] -> [$y]
  * $e is a funcref of type [$x] -> [$y]
  * $d is a funcref of type [] -> []
```

The output of this instruction are two `funcref`s that call the `exec` and `dtor` of the callback respectively.

## `defer #interface-valuetype*`

This is a structured instruction with the following syntax:
```
defer #interface-valuetype*
  #interface-instr*
end
```

The type of this instruction is:
```
[#interface-valuetype*] -> []

Where:
  * #interface-instr* is valid with type [interface-valuetype*] -> []
```

Defer pushes a `defer block` to the `defer stack` in the current function.

When this function would return normally, from a trap, or from an exception, the defer stack is popped until empty. As each defer block is popped, the body of it is executed with the original values provided as input from the defer instruction.
